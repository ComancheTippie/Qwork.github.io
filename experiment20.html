<!DOCTYPE html>
<html>
<head>
    <title>Experiment 20 - Qwork</title>
    <style>
       body {
            background-color: #000000; /* Black background */
            color: #FFFFFF; /* White text */
            font-family: Arial, sans-serif; /* Modern, sans-serif font */
            margin: 0;
            padding: 0;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            
        } 
        header {
            background: url('QImage4.png') no-repeat center center;
            background-size: contain; /* Ensure the image is fully contained within the header */
            height: 400px; /* Height as per the resized image */
            position: relative;
        }
        nav {
            display: flex;
            justify-content: center;
            padding: 10px 0;
        }
        nav a {
            color: #FFFFFF; /* White links */
            margin: 0 20px;
            text-decoration: none;
            font-size: 1.2em;
        }
        nav a:hover {
            color: #00FF00; /* Matrix green for hover state */
        }
        .content-section {
            padding: 20px;
            text-align: left;
        }
        .content-block {
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #00FF00; /* Matrix green border */
        }
        .experiment-image {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image2 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
         .experiment-image3 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image4 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
       
        footer {
            color: #FFFFFF; /* White text */
            text-align: center;
            padding: 20px 0;
        }
        footer a {
            color: #FFFFFF;
            text-decoration: none;
        }
        footer a:hover {
            color: #00FF00; /* Matrix green on hover */
        }
    </style>
</head>
<body>

    <header>
        <!-- Header with the resized image -->
    </header>

    <nav>
        <!-- Navigation links as per wireframe -->
        <a href="try_yourself.html">Try Yourself</a>
        <a href="index.html">Experiments</a>
        <a href="about.html">About Me</a>
    </nav>

    <section class="content-section">
        <h1><center>Creating a Quantum Bitcoin Seed Phrase using IBM's 127-Qubit Sherbrooke Quantum Computer</center></h1>
        <div class="content-block">
         
          

<p>This experiment uses IBM’s 127-Qubit quantum computer 'Sherbrooke', with Qiskit, to generate a Bitcoin seed phrase consisting of 24 words from the BIP-39 standard list. Quantum computers harness key quantum mechanical properties such as superposition and entanglement, enhancing the system's randomness and security. Initially, each qubit is set in a superposition state, ensuring that its measurement outcome is entirely random. These random outcomes directly select words from the BIP-39 list, effectively increasing the entropy and thereby boosting the cryptographic security of the generated seed phrase.</p>

<p><strong>Code Walkthrough</strong><br>
1. Quantum Circuit Initialization:<br>
The quantum circuit is initialized with 24 qubits. Each qubit corresponds to a potential word in the Bitcoin seed phrase. The initialization process involves setting each qubit into a basic state, denoted as ∣0⟩.




<p>2. Superposition:<br>
Each qubit is then put into a state of superposition using Hadamard gates. The Hadamard gate (H) is applied to each qubit, transforming the initial state ∣0⟩ to (∣0⟩ + ∣1⟩)/sqrt(2)​. This operation ensures that each qubit has an equal probability of being measured as either 0 or 1.
<p><center>H∣0⟩ = 1/sqrt(2) * ​(∣0⟩ + ∣1⟩)</center><br>





<p>3. Measurement:<br>
 After applying the Hadamard gates, all qubits are measured. The quantum measurement collapses each qubit's superposition state to either 0 or 1 with equal probability. The outcome for the 24 qubits collectively forms a binary string.


<p>4. Conversion to Indices:<br>
The binary string from the measurements is then interpreted as a sequence of numbers. Since the BIP-39 standard consists of 2048 words, each group of qubits must represent a number from 0 to 2047 (which requires at least 11 bits per number since 2^11=2048). Depending on the length of the measurement string and the bit requirements, the binary string is divided accordingly.
<p><center>Index = int(binary string, 2)mod2048</center><br>

<p>5. Word Selection:<br>
Each index obtained from the binary string is used to select a word from the BIP-39 text file. The selected words collectively form the Bitcoin seed phrase.

<p>6. Compilation and Execution on Quantum Backend:<br>
The quantum circuit is compiled for IBM's Sherbrooke backend. The compiled circuit is then executed. To achieve reliable results, 4000 shots are performed during the execution. This high number of shots helps in achieving statistical significance, ensuring that the probabilistic outcomes of quantum measurements are accurately represented. More shots provide a larger dataset, reducing the impact of quantum noise and operational errors on the final measurement outcomes. 

<p>7. Output:<br>
The final output is a 24-word Bitcoin seed phrase, generated from true quantum randomness.<br>


<p><center> Results:</center><br>
<p><center>Generated Bitcoin Seed Phrase:</center><br>
<p><center>day margin rough nasty attract sample conduct scheme seat defy advance kind mammal hybrid good beauty laundry speak type cousin spike outdoor city fit</center><br>

This experiment effectively demonstrates the use of quantum mechanics to achieve cryptographic security in generating a correctly formatted BIP-39 Bitcoin seed phrase. The approach capitalizes on the inherent randomness of quantum mechanics, providing a potential advantage over classical random number generators in terms of unpredictability and increased entropy.
<br>
<p><center>Sherbrooke Backend and Run:</center><br>



</div>
        <img src="E20image1.png" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">





        <img src="E20image2.png" alt="" class="experiment-image2">
        <p></p>
        <div class="content-block">

The Entropy Heatmap above reflects two key parameters - qubit count and gate fidelity. The horizontal axis represents different levels of gate fidelity from 90% to 99%. Higher fidelity generally leads to more accurate quantum operations. The vertical axis varies from 5 to 24 qubits. More qubits increase the complexity and potential for higher entropy, assuming effective management of decoherence and errors. The color intensity in each cell indicates the entropy level, with brighter colors denoting higher entropy. This visually captures how entropy changes with varying qubit counts and gate fidelities. The heatmap can identify optimal regions where both the number of qubits and the accuracy of quantum operations balance to produce the highest entropy, which is critical for secure quantum cryptographic applications like seed phrase generation. 



            



</div>
        <img src="E20image3.png" alt="" class="experiment-image3">
        <p></p>
        <div class="content-block">

The 2D heatmap above represents the probabilities of quantum states for a slice of 12 qubits from this experiment. The x-axis represents the different quantum states of the last 12 qubits. The y-axis represents different bins of probability values associated with these states. Each cell in the heatmap corresponds to a particular quantum state (on the x-axis) and a probability range (on the y-axis). The color of each cell indicates the frequency of occurrence of that state within the specified probability range. A color closer to yellow or white signifies a higher frequency, while darker colors like blue indicate a lower frequency. White text inside each cell provides the exact count of occurrences for that specific state and probability bin. On the right, a color bar that maps colors to their corresponding counts. This bar helps in understanding which colors represent higher or lower frequencies.




</div>            
    
        
        <p>Code:<br>
            <p><pre><code># imports
import json
from qiskit import QuantumCircuit
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService, RuntimeOptions
import numpy as np

# Setup IBMQ account
API_KEY = 'Your_IBMQ_Key_Here_O-`'  # Replace with IBMQ API key
service = QiskitRuntimeService(channel='ibm_quantum', token=API_KEY)

backend = service.backend('ibm_sherbrooke')  # IBM backend 

# Load BIP-39 words from text file
with open('/Users/Documents/BIPwords.txt', 'r') as file:
    bip39_words = file. read().splitlines()

def generate_seed_phrase(num_qubits, backend):
    circ = QuantumCircuit(num_qubits)
    for i in range(num_qubits):
        circ.h(i)  # Apply Hadamard gate to create superposition
    circ.measure_all()

    # Transpile the circuit for backend
    pm = generate_preset_pass_manager(optimization_level=1, target=backend. target)
    transpiled_circuits = pm. run([circ])

    # Execute the circuit with Qiskit Runtime
    options = RuntimeOptions(backend=backend. name)
    job = service. run(program_id="sampler", inputs={'circuits': transpiled_circuits}, options=options)
    result = job.result()

    # Accessing quasi-probabilities from SamplerResult
    quasi_probs = result.quasi_dists[0]  # Get the quasi-probability distribution of the first (and only) circuit
    # Check if quasi_probs is empty or contains zero probabilities
    if not quasi_probs or all(prob == 0 for prob in quasi_probs.values()):
        raise ValueError("Invalid or zero quasi-probabilities obtained from the quantum computation.")

    # Extract probabilities and normalize them
    probabilities = list(quasi_probs.values())
    normalized_probabilities = np.array(probabilities) / np.sum(probabilities)
    # Randomly choose indices based on the normalized probabilities
    indices = np.random.choice(len(normalized_probabilities), size=num_qubits, p=normalized_probabilities)
    seed_words = [bip39_words[i % 2048] for i in indices]

    return seed_words

# Generate the seed phrase using the quantum computer
seed_phrase = generate_seed_phrase(24, backend)

# Print the generated seed phrase
print("Generated Bitcoin Seed Phrase:", ' '.join(seed_phrase))
    
# end     

</code></pre>
</p>
            
 </div>
        <img src="E14image4.png" alt="" class="experiment-image4">
        
           
            
    

  

    <footer>
        <!-- Footer content -->
        <a href="mailto:stevetippeconnic@gmail.com">Contact</a>
    </footer>

</body>
</html>
