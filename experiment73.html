

<!DOCTYPE html>
<html>
<head>
    <title>Experiment 20 - Qwork</title>
    <style>
       body {
            background-color: #000000; /* Black background */
            color: #FFFFFF; /* White text */
            font-family: Arial, sans-serif; /* Modern, sans-serif font */
            margin: 0;
            padding: 0;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            
        } 
        header {
            background: url('QImage4.png') no-repeat center center;
            background-size: contain; /* Ensure the image is fully contained within the header */
            height: 400px; /* Height as per the resized image */
            position: relative;
        }
        nav {
            display: flex;
            justify-content: center;
            padding: 10px 0;
        }
        nav a {
            color: #FFFFFF; /* White links */
            margin: 0 20px;
            text-decoration: none;
            font-size: 1.2em;
        }
        nav a:hover {
            color: #00FF00; /* Matrix green for hover state */
        }
        .content-section {
            padding: 20px;
            text-align: left;
        }
        .content-block {
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #00FF00; /* Matrix green border */
        }
        .experiment-image {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image2 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
         .experiment-image3 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image4 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
       
        footer {
            color: #FFFFFF; /* White text */
            text-align: center;
            padding: 20px 0;
        }
        footer a {
            color: #FFFFFF;
            text-decoration: none;
        }
        footer a:hover {
            color: #00FF00; /* Matrix green on hover */
        }
    </style>
</head>
<body>

    <header>
        <!-- Header with the resized image -->
    </header>

    <nav>
        <!-- Navigation links as per wireframe -->
        <a href="try_yourself.html">Try Yourself</a>
        <a href="index.html">Experiments</a>
        <a href="about.html">About Me</a>
    </nav>

    <section class="content-section">
        <h1><center> Breaking a 5-Bit Elliptic Curve Key with a 133-Qubit Quantum Computer </center></h1>
        <div class="content-block">
         
This experiment breaks a 5-bit elliptic curve cryptographic key using Shor’s algorithm. Executed onIBM’s 133-qubit ibm_torino with Qiskit, a 15-qubit circuit, comprised of 10 logical qubits and 5 ancilla, interferes over ℤ₃₂ to extract the secret scalar k from the public key relation Q = kP, without ever encoding k directly into the oracle. From 16,384 shots, the quantum interference reveals a diagonal ridge in the 32x32 QFT outcome space. The quantum circuit, over 67,000 layers deep, produced valid interference patterns despite extreme circuit depth, and classical post-processing revealed k = 7 in the top 100 invertible (a, b) results.
 <br>  
Code Walkthrough
 <br>           
<p>1. Group Encoding <br>
Restrict attention to the order‑32 subgroup ⟨𝑃⟩ of an elliptic curve over 𝐹_p.<br>
Map points to integers: <br>
0𝑃 -> 0,  1𝑃 -> 1, …, 31𝑃 -> 31.<br>
Group law becomes modular addition: <br>
(𝑥𝑃) + (𝑦𝑃) = ((𝑥 + 𝑦) mod 32))𝑃.<br>
This experiment uses an elliptic curve over a finite field  F_p​ with a cyclic subgroup of order 32, generated by a point P. The public point is Q = 7P. This abstracts the curve arithmetic by mapping points to indices in ℤ₃₂ (P -> 1, Q -> 23) in the code, assuming precomputed scalar multiplications. An example curve is E: y^2 = x^3 + 2x + 3 (mod 97), with P = (5, 22) (order 32) and Q = 7P = (73, 64), verifiable using SageMath.
<br>
<p>2. Quantum Registers<br>
Register a: five qubits for the exponent 𝑎 ∈ {0, …, 31}.<br>
Register b: five qubits for 𝑏 ∈ {0, …, 31}.<br>
Register p: five qubits initialized to ∣0⟩ to hold the point index.<br>
Classical register c: an 10-bit register to record the measured values of a and b.<br>
    
<p>3. Superposition Preparation<br>
Apply Hadamards to every qubit in a and b:<br>
<br>
1/32 (∑_(a, b=0))^31 ∣a⟩_a ∣b⟩_b ∣0⟩_p
    
<br>


<p>4. Oracle construction U_f<br>
Goal is a reversible map: <br>
∣a⟩ ∣b⟩ ∣0⟩ -> ∣a⟩ ∣b⟩ ∣aP + bQ⟩.<br>
Add aP: for each bit a_i (weight 2^𝑖), add (2^𝑖 P) mod 32<br>
Add bQ: compute (2^𝑖 𝑄) mod 32, then add controlled on 𝑏_𝑖.<br>
These use 5-qubit controlled permutation gates. All constants are derived from the elliptic curve’s generator P and the public point Q. <br>
No gate ever directly references the secret k.<br>




<p>5. Global State after Oracle<br>
1/32 ∑_(a, b) ∣a⟩ ∣b⟩ ∣f(a, b)⟩, where f(a, b) = a + kb (mod 32).
  <br>
	
<p>6. Isolate Point Register <br>
The algorithm needs only the phase relation in 𝑎, 𝑏. A barrier isolates p.<br>


<p>7. Quantum Fourier Transform (QFT)<br>                       
∣a⟩ -> 1/√32 (∑_( u=0))^31 e^((2πi)/32 au) ∣u⟩, 
<br>                            
∣b⟩ -> 1/√32 (∑_(v=0))^31 e^((2πi)/32 bv) ∣v⟩.
<br>

  
<p>8. Interference Pattern <br>
The joint amplitude for observing (u, v) is:<br>
1/32 ∑_(a, b) e^((2πi/32)(au + bv)) δ_(a + kb ≡ 0) = 1/32 δ_(u + kv ≡ 0 (mod 32)), which forms a diagonal ridge in the 32x32 outcome grid. 
<br>

<p>9. Measurement<br>
Measure all ten logical qubits. Outcomes concentrate on the 32 distinct pairs satisfying u + kv ≡ 0 (mod 32).
<br>   

<p>10. Classical Post-Processing<br>
Bitstrings are endian-flipped and parsed into (a, b) pairs. Keep only rows where gcd⁡(b, 32) = 1, ensuring b is invertible. The candidate key is computed as:<br>
k = (-a) b^(-1) mod 32<br>
The script then:<br>
Extracts the top 100 highest-count invertible (a, b) results. <br>
Computes k for each. <br>
Prints each (a, b) pair, recovered k, and count. <br>
Declares success if k = 7 appears in the top 100.
<br>   

<p>11. Verification and Storage<br>
The correct scalar k = 7 is confirmed if it appears in the top 100 invertible results.<br>
All raw bitstring counts, qubit layout, and metadata are saved to JSON for further visualization and analysis.<br>   


<p><center> Results:</center><br>
<br>
<br>
2025-06-25 19:41:29,294 | INFO | Circuit depth 67428, gate counts OrderedDict({'sx': 56613, 'cz': 34319, 'rz': 15355, 'x': 157, 'measure': 10, 'barrier': 1})<br>
base_primitive._run:INFO:2025-06-25 19:41:29,994: Submitting job using options {'options': {}, 'version': 2, 'support_qiskit': True}<br>
<br>
SUCCESS — k = 7 found in top 100 results<br>
<br>
Top 100 invertible (a, b) pairs and recovered k:<br>
  (a= 8, b=11)  →  k =  8   (count = 63)<br>
  (a=12, b= 9)  →  k = 20   (count = 58)<br>
  (a= 0, b= 3)  →  k =  0   (count = 54)<br>
  (a= 1, b= 9)  →  k =  7   (count = 54) < <br>
  (a=28, b= 1)  →  k =  4   (count = 53)<br>
  (a= 0, b=11)  →  k =  0   (count = 53)<br>
  (a= 8, b= 9)  →  k = 24   (count = 53)<br>
  (a= 8, b= 3)  →  k =  8   (count = 53)<br>
...<br>
(a=11, b= 3)  →  k =  7   (count = 41) <<br>
...<br>
(a=25, b= 1)  →  k =  7   (count = 32) <<br>
<br>
This run successfully retrieved the secret scalar k = 7 using a 5-bit ECC key (order-32 subgroup), extending my previous 4-bit attack to a space with 1024 possible (a, b) combinations and φ(32) = 16 invertible b values.
<br>
k = 7 appears three times in the top 100:<br>
(a = 1, b = 9) -> k = 7 with 54 counts<br>
(a = 11, b = 3) -> k = 7 with 41 counts<br>
(a =25, b = 1) -> k = 7 with 32 counts<br>
These are high-frequency states, making them credible attack vectors under classical post-processing.
<br>
The counts exhibit concentration around structured modular relations: a + kb ≡ 0 mod 32. These appear as diagonal ridges in the 32x32 measurement space. Several k values recur often (k = 0, 24, 28), showing the probabilistic overlap intrinsic to quantum interference, some of these are false positives from noise or aliasing with other modular equivalences. 
<br>
Circuit depth was 67,428, with a total of 106,455 gates, reflecting a large, complex quantum routine for controlled modular index arithmetic. This may be the largest amount gates I've used in a circuit. 
<br>
Gate counts for the circuit<br>
sx: 56613<br>
cz: 34319<br>
rz: 15355<br>
x: 157<br>
measure: 10<br>
barrier: 1<br>
Total gates: 106455<br>
Depth: 67428<br>
Width: 133 qubits  |  10 clbits<br>

This experiment took 54 seconds to complete on 'ibm_torino'.<br>

The noise profile is nonuniform but decaying, meaning the quantum system likely resolved dominant harmonics in the interference but blurred out finer structures. The distribution tail still contains valid k = 7 candidates, this supports dictionary-style quantum attacks where top-N result scans (N = 100) are sufficient to retrieve the key.<br>
<br>
  <img src="e73i1.png" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">
<br>

The Raw Count Heatmap (a vs b) above (full code on Qwork) shows a 32x32 grid represents the observed counts for each pair (a, b) after running Shor’s circuit. The heatmap shows a banded and uneven distribution, indicating interference ridges, not noise. Certain rows (a values) have visibly higher concentration, suggesting constructive interference along specific a + kb ≡ 0 mod 32 solutions. 
<br>
The Histogram of Recovered k Values above (full code on Qwork) aggregates the total counts for each recovered scalar key k ∈ Z₃₂, derived via k = −ab^(−1) mod  32. A huge spike at k = 0 and another around k = 24 are dominant. The correct key k = 7 is not the highest, but is well represented (~54 + 41 + 32 = 127 counts across multiple (a, b) pairs). This shows that hackers can dictionary attack a larger amount of results.
<br>
The Bitstring Rank vs Count (Log-Scale) above (full code on Qwork) shows a Zipf-like rank plot of all bitstrings by descending count. The log-scale y-axis shows an exponential tail, most outcomes occur <10 times. The head (top ~50) bitstrings have steeply higher probability, indicating constructive interference peaks. You could build a quantum heuristic dictionary attack that harvests only the top N bitstrings with exponential return on signal. This validates the quantum signal-to-noise structure is still intact even with longer circuits (67428 depth).
<br>
The Locations of (a, b) Decoding to k = 7 above (full code on Qwork) shows each dot is an (a, b) pair that decoded to k = 7. Color intensity equals the number of times this pair occurred.  The plot shows a relatively uniform distribution across (a, b), but with local peaks at (1, 9), (11, 3), (25, 1). Multiple (a, b) combinations converge to k = 7 with non-uniform multiplicity. From a cryptanalytic standpoint, this validates that Shor’s algorithm can reliably break ECC keys even when the correct k is not the top 1 result.<br>
<br>
          <img src="e73i2.png" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">
<br>
The Invertibility Mask for b Register above (full code on Qwork) shows a bar chart of counts for each b ∈ {0, …, 31} that are coprime with 32 (gcd⁡(b, 32) = 1, only these are invertible modulo 32 and useful for recovering k via: k = (−a)b^(−1) mod 32. Invertible b's are well-populated, showing the circuit did produce recoverable candidates. More uniformity here would increase post-processing power, ideally, these would be flat. 
<br>
The Modular Inverse Frequency Map: b vs b^(−1) mod 32 above (full code on Qwork) shows a heatmap of how often each invertible b maps to each corresponding modular inverse b^(−1) mod  32, weighted by result counts. Most points fall on a clean bijective line, each b maps cleanly to a unique b^(−1), confirming correctness of modular inversion. Brighter regions (near bottom left or top right) show favored b's from the quantum sampling. No off-diagonal noise or clustering, good sign of clean modular structure preserved.
<br>
The a + 7b mod 32 Map above (full code on Qwork) assumes k = 7 and plots the value of (a + 7b) mod  32 across all results. The distribution is nearly uniform. This suggests no sharp interference ridge like in the 4-bit case. Why? The 5-bit circuit (with 10 logical qubits) spreads amplitude thinner across 1024 outcomes, reducing contrast. Yet the correct key was still recoverable, indicating many weakly constructive paths, rather than a few dominant ones. 
<br>
The ECC Attack Efficiency: Valid vs Invalid b above (full code on Qwork) show total counts from samples with invertible b (useful for key recovery) vs. non-invertible b (useless). Over half the results are wasted on invalid b values (gcd⁡(b, 32) != 1). Next design for a 6 bit break could use oracle masking or postselection filtering on valid b-domains. <br>
<br>
          <img src="e73i3.png" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">
<br>

The Heatmap: (a, b) with Invertible b (mod 32) above (full code on Qwork) focuses only on (a, b) pairs where b is invertible modulo 32, a necessary condition for recovering k. It shows where quantum interference is concentrating within the 1024-point space. The high-intensity regions reveal preferred interference paths, suggesting the quantum state evolved non-uniformly, possibly favoring certain orbits under modular multiplication. It confirms strong enough signal coherence in some regions to isolate valid candidates. 
<br>
The Distribution of Phase Ridge Angles above (full code on Qwork) bins the angles formed by (-a, b) vectors in the plane, modulo π, which roughly correspond to phase ridges in QFT space. Peaks in the histogram indicate strong alignments, resonances, of the form u + kv ≡ 0, meaning the circuit successfully encoded k into the interference pattern even though the full state space is vast. The multiple dominant angles suggest harmonics of the hidden shift are present. 
<br>
The Residue Map of a + 7b mod 32 above (full code on Qwork) visualizes the output residue for the specific target key k = 7, across the entire (a, b) space. Any consistent bands or symmetries here indicate how well the interference amplified valid solutions (where this value equals 0). You can observe which regions of the 1024 lattice correspond to a + 7b ≡ 0, validating that the oracle’s structure led to successful key imprinting.
<br>
The Noise: Variance of Count across b for fixed a above (full code on Qwork) shows how noisy or stable the output counts were for each fixed a as we vary b. High variance means some b values lead to strong amplification while others do not, implying circuit sensitivity or backend noise for that a-row. Smooth regions imply quantum coherence, while spikes may point to decoherence or error propagation during oracle evaluation.
<br>
In the end, this experiment successfully broke a 5-bit elliptic curve key using Shor’s algorithm executed on IBM’s 133-qubit quantum processor, extending the prior 4-bit result into a significantly larger interference space (32x32 = 1024 outcomes). This circuit encoded the oracle over ℤ₃₂ without ever referencing the secret scalar k, and leveraged modular group arithmetic to entangle the scalar into phase interference. The quantum circuit, over 67,000 layers deep, produced valid interference patterns despite extreme circuit depth, and classical post-processing revealed k = 7 in the top 100 invertible (a, b) results. Through visualizations, this experiment confirmed diagonal ridge structures, invertibility masks, and harmonic alignment of interference ridges, validating that quantum coherence remained strong enough to amplify the correct modular relationship. This establishes that Shor’s algorithm continues to scale under deeper circuit regimes and that dictionary-based key recovery strategies (top 100 enumeration) remain viable as bit-length increases, showing clear quantum advantage even under noisy real-world conditions.<br>
<br>
  <p>Code:<br>
        <p><pre><code>
# Main circuit
# Imports
import logging, json
from math import gcd
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit.circuit.library import UnitaryGate, QFT
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2
import pandas as pd

# IBMQ
TOKEN = "YOUR_IBMQ_API_KEY"
INSTANCE = "YOUR_IBMQ_CRN"
BACKEND  = "ibm_torino"
CAL_CSV  = "/Users/steventippeconnic/Downloads/ibm_torino_calibrations_2025-06-26T02_21_07Z.csv"
SHOTS    = 16384

# Toy‑curve parameters  (order‑32 subgroup of E(F_p))
ORDER = 32  # |E(F_p)| = 32
P_IDX = 1   # Generator P  -> index 1
Q_IDX = 23  # Public point Q = kP, here “23 mod 32” for k = 7

# Logging helper
logging.basicConfig(level=logging .INFO,
                    format="%(asctime)s | %(levelname)s | %(message)s")
log = logging.getLogger(__name__)

# Calibration‑based qubit pick
def best_qubits(csv_path: str, n: int) -> list[int]:
    df = pd .read_csv(csv_path)
    df.columns = df.columns.str.strip()
    winners = (
        df.sort_values(["√x (sx) error", "T1 (us)", "T2 (us)"],
                       ascending=[True, False, False])
        ["Qubit"].head(n).tolist()
    )
    log .info("Best physical qubits: %s", winners)
    return winners

N_Q = 5
N_Q_TOTAL = N_Q * 3  # a, b, point
PHYSICAL = best_qubits(CAL_CSV, N_Q_TOTAL)

# Constant-adder modulo 32 as a reusable gate
def add_const_mod32_gate(c: int) -> UnitaryGate:
    """Return a 5‑qubit gate that maps |x⟩ ↦ |x+c (mod 32)⟩."""
    mat = np.zeros((32, 32))
    for x in range(32):
        mat[(x + c) % 32, x] = 1
    return UnitaryGate(mat, label=f"+{c}")

ADDERS = {c: add_const_mod32_gate(c) for c in range(1, 32)}

def controlled_add(qc: QuantumCircuit, ctrl_qubit, point_reg, constant):
    """Apply |x⟩ → |x+constant (mod 32)⟩ controlled by one qubit."""
    qc.append(ADDERS[constant].control(), [ctrl_qubit, *point_reg])

# Oracle  U_f : |a⟩|b⟩|0⟩ ⟶ |a⟩|b⟩|aP + bQ⟩   (index arithmetic mod 32)
def ecdlp_oracle(qc, a_reg, b_reg, point_reg):
    for i in range(N_Q):
        constant = (P_IDX * (1 << i)) % ORDER
        if constant:
            controlled_add(qc, a_reg[i], point_reg, constant)

    for i in range(N_Q):
        constant = (Q_IDX * (1 << i)) % ORDER
        if constant:
            controlled_add(qc, b_reg[i], point_reg, constant)

# Build the full Shor circuit
def shor_ecdlp_circuit() -> QuantumCircuit:
    a = QuantumRegister(N_Q, "a")
    b = QuantumRegister(N_Q, "b")
    p = QuantumRegister(N_Q, "p")
    c = ClassicalRegister(N_Q * 2, "c")
    qc = QuantumCircuit(a, b, p, c, name="ECDLP_32pts")

    qc.h(a)
    qc.h(b)
    ecdlp_oracle(qc, a, b, p)
    qc.barrier()

    qc.append(QFT(N_Q, do_swaps=False), a)
    qc.append(QFT(N_Q, do_swaps=False), b)

    qc.measure(a, c[:N_Q])
    qc.measure(b, c[N_Q:])

    return qc

# IBM Runtime execution
service = QiskitRuntimeService(channel="ibm_cloud",
                               token=TOKEN,
                               instance=INSTANCE)
backend = service.backend(BACKEND)
log .info("Backend → %s", backend .name)

qc_raw = shor_ecdlp_circuit()
trans = transpile(qc_raw,
                  backend=backend,
                  initial_layout=PHYSICAL,
                  optimization_level=3)
log .info("Circuit depth %d, gate counts %s", trans.depth(), trans.count_ops())

sampler = SamplerV2(mode=backend)
job = sampler .run([trans], shots=SHOTS)
result = job.result()

# Classical post‑processing
creg_name = trans.cregs[0].name
counts_raw = result[0].data.__getattribute__(creg_name).get_counts()

def bits_to_int(bs): return int(bs[::-1], 2)

counts = {(bits_to_int(k[N_Q:]), bits_to_int(k[:N_Q])): v
          for k, v in counts_raw.items()}
top = sorted(counts.items(), key=lambda kv: kv[1], reverse=True)

# Success criteria. Check top 100 invertible rows for k = 7
top_invertibles = []
for (a_val, b_val), freq in top:
    if gcd(b_val, ORDER) != 1:
        continue
    inv_b = pow(b_val, -1, ORDER)
    k_candidate = (-a_val * inv_b) % ORDER
    top_invertibles.append(((a_val, b_val), k_candidate, freq))
    if len(top_invertibles) == 100:
        break

# Check for success and print results
found_k7 = any(k == 7 for (_, k, _) in top_invertibles)

if found_k7:
    print("\nSUCCESS — k = 7 found in top 100 results\n")
else:
    print("\nWARNING — k = 7 NOT found in top 100 results\n")

print("Top 100 invertible (a, b) pairs and recovered k:")
for (a, b), k, count in top_invertibles:
    tag = " <<<" if k == 7 else ""
    print(f"  (a={a:2}, b={b:2})  →  k = {k:2}   (count = {count}){tag}")

# Save raw data
out = {
    "experiment": "ECDLP_32pts_Shors",
    "backend": backend .name,
    "physical_qubits": PHYSICAL,
    "shots": SHOTS,
    "counts": counts_raw
}
JSON_PATH = "/Users/steventippeconnic/Documents/QC/Shors_ECC_5_Bit_Key_0.json"
with open(JSON_PATH, "w") as fp:
    json.dump(out, fp, indent=4)
log .info("Results saved → %s", JSON_PATH)

# End


/////////////////////////////////////////////////////////////////

          
# Code for all visuals from experiment JSON
# imports
import json
import matplotlib.pyplot as plt
import numpy as np
from math import gcd
import seaborn as sns
from collections import Counter
from math import gcd
from itertools import product

# Load JSON results
FILE_PATH = '/Users/steventippeconnic/Documents/QC/Shors_ECC_5_Bit_Key_0.json'
with open(FILE_PATH, 'r') as f:
    data = json.load(f)

counts_raw = data["counts"]
ORDER = 32
N_Q = 5  # 5-bit key => 5 qubits for a and b
counts = data['counts']

# Parse raw bitstrings into (a, b) pairs
def bits_to_int(bs): return int(bs[::-1], 2)  # endian flip

# Convert bitstrings to (a, b) pairs
def bits_to_int_two(bits):
    return int(bits, 2)

parsed_counts = {
    (bits_to_int(k[:N_Q]), bits_to_int(k[N_Q:])): v
    for k, v in counts_raw.items()
}

parsed = []
for bitstring, count in counts.items():
    bitstring = bitstring[::-1]  # endian flip
    a = bits_to_int_two(bitstring[:N_Q])
    b = bits_to_int_two(bitstring[N_Q:2*N_Q])
    parsed.append((a, b, count))

# 2D Heatmap of raw counts (a vs b) 
heatmap = np.zeros((ORDER, ORDER))
for (a, b), v in parsed_counts.items():
    heatmap[a, b] = v

plt.figure()
plt.imshow(heatmap, cmap='viridis')
plt.title("Raw Count Heatmap (a vs b)")
plt.xlabel("b value")
plt.ylabel("a value")
plt.colorbar(label="Counts")
plt.show()

# Histogram of recovered k values 
k_counts = {}
for (a, b), v in parsed_counts.items():
    if gcd(b, ORDER) == 1:
        inv_b = pow(b, -1, ORDER)
        k = (-a * inv_b) % ORDER
        k_counts[k] = k_counts.get(k, 0) + v

ks, vs = zip(*sorted(k_counts.items()))
plt.figure()
plt.bar(ks, vs, color='darkgreen')
plt.title("Histogram of Recovered k Values")
plt.xlabel("k value")
plt.ylabel("Sum of Counts")
plt.xticks(range(0, ORDER, 2))
plt.grid(axis='y')
plt.show()

# Bitstring Rank vs Count (log scale) 
sorted_counts = sorted(parsed_counts.items(), key=lambda x: x[1], reverse=True)
plt.figure()
plt.plot(range(len(sorted_counts)), [v for (_, v) in sorted_counts], marker='.')
plt.title("Bitstring Rank vs. Count")
plt.xlabel("Rank")
plt.ylabel("Counts")
plt.yscale("log")
plt.grid(True, which="both", linestyle="--", alpha=0.5)
plt.show()

# (a, b) locations that decode to k = 7 
ab_k7 = [(a, b, v) for (a, b), v in parsed_counts.items()
         if gcd(b, ORDER) == 1 and ((-a * pow(b, -1, ORDER)) % ORDER) == 7]

if ab_k7:
    a7, b7, v7 = zip(*ab_k7)
    plt.figure()
    plt.scatter(b7, a7, c=v7, cmap='plasma', s=100, edgecolors='black')
    plt.title("Locations of (a, b) Decoding to k = 7")
    plt.xlabel("b value")
    plt.ylabel("a value")
    plt.colorbar(label="Counts")
    plt.grid(True)
    plt.show()
else:
    print("No (a, b) pairs found that decode to k = 7.")


# Invertibility Mask 
invertibility_counts = [0] * ORDER
for (a, b), count in parsed_counts.items():
    if gcd(b, ORDER) == 1:
        invertibility_counts[b] += count

plt.figure()
plt.bar(range(ORDER), invertibility_counts, color='black')
plt.title("Invertibility Mask for b Register")
plt.xlabel("b value")
plt.ylabel("Total Counts (if gcd(b, 32) = 1)")
plt.grid(True)
plt.show()

# Modular Inverse Frequency Heatmap 
mod_inv_heat = np.zeros((ORDER, ORDER))
for (a, b), count in parsed_counts.items():
    if gcd(b, ORDER) == 1:
        b_inv = pow(b, -1, ORDER)
        mod_inv_heat[b][b_inv] += count

plt.figure()
plt.imshow(mod_inv_heat, cmap='magma', origin='lower')
plt.title("Modular Inverse Frequency Map: b vs b⁻¹ (mod 32)")
plt.xlabel("b⁻¹ mod 32")
plt.ylabel("b value")
plt.colorbar(label="Counts")
plt.show()

# a + 7*b mod 32 Mapping 
akb_counts = [0] * ORDER
for (a, b), count in parsed_counts.items():
    linear_val = (a + 7 * b) % ORDER
    akb_counts[linear_val] += count

plt.figure()
plt.bar(range(ORDER), akb_counts, color='blue')
plt.title("a + 7·b mod 32 Map")
plt.xlabel("a + 7·b mod 32")
plt.ylabel("Sum of Counts")
plt.grid(True)
plt.show()

# ECC Attack Efficiency 
invertible_total = sum(count for (a, b), count in parsed_counts.items() if gcd(b, ORDER) == 1)
noninvertible_total = sum(count for (a, b), count in parsed_counts.items() if gcd(b, ORDER) != 1)

plt.figure()
plt.bar(['Invertible b', 'Non-Invertible b'], [invertible_total, noninvertible_total], color=['green', 'red'])
plt.title("ECC Attack Efficiency: Valid vs Invalid b")
plt.ylabel("Total Sampled Counts")
plt.show()

# Invertible b Density Heatmap 
invertible_counts = np.zeros((32, 32))
for a, b, count in parsed:
    if gcd(b, 32) == 1:
        invertible_counts[a][b] += count

plt.figure()
sns.heatmap(invertible_counts, cmap='cividis', cbar_kws={'label': 'Counts'})
plt.xlabel("b")
plt.ylabel("a")
plt.title("Heatmap: (a, b) with Invertible b (mod 32)")
plt.show()

# k-Spectrum Phase Ridge Angle vs Count 
ridge_angles = Counter()
for a, b, count in parsed:
    if gcd(b, 32) == 1:
        try:
            k = (-a * pow(b, -1, 32)) % 32
            angle = (np.arctan2(-a % 32, b)) % np.pi  # modulo for unique reps
            ridge_angles[round(angle, 2)] += count
        except:
            continue

plt.figure()
plt.bar(ridge_angles.keys(), ridge_angles.values(), width=0.03, color='firebrick')
plt.xlabel("Ridge Angle (rad)")
plt.ylabel("Total Counts")
plt.title("Distribution of Phase Ridge Angles")
plt.show()

# (a + k*b) mod 32 Heatmap for k=7 
residue_map = np.zeros((32, 32))
for a, b, count in parsed:
    residue = (a + 7 * b) % 32
    residue_map[a][b] = residue

plt.figure()
sns.heatmap(residue_map, cmap='Spectral', cbar_kws={'label': 'Residue'})
plt.xlabel("b")
plt.ylabel("a")
plt.title("Residue Map of a + 7b mod 32")
plt.show()

# Noise Distribution: Count Variance across b for fixed a=7 
b_axis = list(range(32))
variances = []
for a in range(32):
    counts_per_b = [c for x, y, c in parsed if x == a and y in b_axis]
    var = np.var(counts_per_b)
    variances.append(var)

plt.figure()
plt.plot(range(32), variances, marker='o', color='indigo')
plt.xlabel("a")
plt.ylabel("Variance over b")
plt.title("Noise: Variance of Count across b for fixed a")
plt.grid(True)
plt.show()

# End.

</code></pre>
</p>
            
 </div>
        <img src="e73i4.png" alt="" class="experiment-image4">
        <p></p>
        <div class="content-block">

           
            <br>


        
    

  

    <footer>
        <!-- Footer content -->
        <a href="mailto:stevetippeconnic@gmail.com">Contact</a>
    </footer>

</body>
</html>
