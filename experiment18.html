<!DOCTYPE html>
<html>
<head>
    <title>Experiment 18 - Qwork</title>
    <style>
       body {
            background-color: #000000; /* Black background */
            color: #FFFFFF; /* White text */
            font-family: Arial, sans-serif; /* Modern, sans-serif font */
            margin: 0;
            padding: 0;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            
        } 
        header {
            background: url('QImage4.png') no-repeat center center;
            background-size: contain; /* Ensure the image is fully contained within the header */
            height: 400px; /* Height as per the resized image */
            position: relative;
        }
        nav {
            display: flex;
            justify-content: center;
            padding: 10px 0;
        }
        nav a {
            color: #FFFFFF; /* White links */
            margin: 0 20px;
            text-decoration: none;
            font-size: 1.2em;
        }
        nav a:hover {
            color: #00FF00; /* Matrix green for hover state */
        }
        .content-section {
            padding: 20px;
            text-align: left;
        }
        .content-block {
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #00FF00; /* Matrix green border */
        }
        .experiment-image {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image2 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
         .experiment-image3 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image4 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
       
        footer {
            color: #FFFFFF; /* White text */
            text-align: center;
            padding: 20px 0;
        }
        footer a {
            color: #FFFFFF;
            text-decoration: none;
        }
        footer a:hover {
            color: #00FF00; /* Matrix green on hover */
        }
    </style>
</head>
<body>

    <header>
        <!-- Header with the resized image -->
    </header>

     <nav>
        <a href="try_yourself.html">Try</a>
        <a href="index.html">Experiments</a>
	    <a href="visuals.html">Waves</a>
        <a href="about.html">About</a>
    </nav>

    <section class="content-section">
        <h1><center>Exploring abstract Electron-Positron Annihilation on IBM's 127-Qubit Quantum Computer Osaka</center></h1>
        <div class="content-block">
         
          

<p>Leveraging quantum computing and Qiskit, particle interactions can be abstractly represented and studied, offering a novel way for exploring complex probabilistic phenomena in particle physics. Quantum computers harness superposition and entanglement properties of quantum bits (qubits) to simulate the dynamics of particle interactions more efficiently than classical computers. By encoding the states and interactions of particles into quantum circuits, we can simulate various scattering processes, decay channels, and particle production mechanisms. Quantum computers could enable the exploration quantum tunneling effects, strong and weak force interactions, and the behavior of particles in extreme conditions such as those encountered in high energy collisions.</p>
<p>This experiment explores the abstract annihilation process of an electron-positron pair through quantum computing. Electrons and positrons, fundamental particles with opposite charges and identical masses, exhibit unique interactions when brought together. Upon collision, they can annihilate each other, leading to the creation of various particles, such as photons, neutrinos, or muons. This experiment aims to abstractly create the beginning of this process using a quantum circuit.  </p>


            
<p><strong>Code Walkthrough</strong><br>
1. Initialization: <br>
We define a quantum circuit with two qubits, symbolizing the electron and positron states.
Applying Hadamard gates (H) to both qubits, we establish superposition states, ensuring they exist in a coherent mixture of |0⟩ and |1⟩. The superposition state can be represented by the equation:
<p><center>∣ψ⟩ = H∣0⟩ = 1/sqrt(2) * ​(∣0⟩ + ∣1⟩)</center><br>
Applying this to both qubits, the initial state of the system is:
<p><center>∣ψ_initial​⟩ = 1/sqrt(2) * ​(∣00⟩ + ∣01⟩ + ∣10⟩ + ∣11⟩)</center><br>




<p>2. Annihilation Gate:<br>
We define a bespoke gate, the annihilation gate, designed to emulate the interaction between the electron and positron. The annihilation process is simulated by a custom gate sequence that includes a controlled-NOT (CNOT) gate, a Hadamard gate, a Pauli-X gate, and another CNOT gate. This sequence is designed to reflect the transformation of the electron-positron pair into another state, mimicking the annihilation process. The CNOT gate entangles the qubits, reflecting the interaction between the electron and positron.
<br>
The annihilation gate comprises a sequence of quantum operations:
Implement a controlled-NOT (CNOT) gate, where the electron qubit serves as the control and the positron qubit as the target. Mathematically, this gate can be represented as:
<p><center>CNOT =​ (1, 0, 0, 0, 0, 1, 0, 0, ​0, 0, 0, 1, ​0, 0, 1, 0​) - 4x4 matrix</center><br>
Apply a Hadamard gate to the electron qubit to generate entanglement between the qubits. Mathematically, the Hadamard gate is represented as:
<p><center>H = 1/sqrt(2) * (1, 1, ​1, −1​) - 2x2 matrix</center><br>
Employ a Pauli-X gate (or NOT gate) to flip the state of the electron qubit from |0⟩ to |1⟩.
Apply another CNOT gate, this time with the positron qubit as the control and the electron qubit as the target.




<p>3. Measurement:<br>
Conduct measurements on both qubits to get the final outcome of the annihilation process. The act of measurement collapses the quantum superposition into definitive classical states. 

<p>4. Data Analysis: <br>
Measurement counts, transpiled circuit, backend information, job ID, and execution status are saved to a JSON.  We also generate a histogram of the frequency of different outcomes for the annihilation process.





<p><center> Results:</center><br>
Using backend:  ibm_kyoto<br>
{'10': 1625, '11': 485, '00': 383, '01': 1507}<br>
Probability of '00': 9.575%<br>
Probability of '01': 37.675%<br>
Probability of '10': 40.625%<br>
Probability of '11': 12.125%<br>

</div>
        <img src="E18image1.png" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">

Above is a Feynman-like Quantum Diagram (full code below) that is based on the run data. In this diagram, blue and red lines represent the paths of an incoming electron and positron. The point where these paths converge represents the interaction vertex. Green lines represent the possible outcomes (quantum states) of this interaction, with the opacity of each line corresponding to the relative number of counts for each outcome, serving as a proxy for the probability amplitude. The labels next to the green lines indicate the quantum state and the corresponding measurement count from the simulation data.

<br>
Probabilistic Nature vs. Deterministic Outcomes: While the quantum simulation inherently exhibits a probabilistic nature due to measurement, real-world annihilation events under specific conditions can have deterministic outcomes (e.g. exactly two photons produced). The quantum simulation mirrors the underlying quantum mechanics governing these processes, emphasizing the role of probability amplitudes and non-determinism. The higher probabilities for '01' and '10' can be abstractly interpreted as the simulation's equivalent of the conservation laws in real collisions, indicating a balance between the possible states post annihilation.

<br>

Symmetry and Quantum States: 
The simulation outcomes show a notable symmetry in probabilities, with '01' and '10' being more probable than '00' and '11'. This reflects the superposition and entanglement of quantum states where certain states are more likely due to the quantum gates applied, resembling the balanced outcomes expected in particle annihilation where different states (photon directions, polarizations) are equally probable in a symmetric setup.
            
            
            
<br>

Quantum Interference: 
The variation in probabilities can also be attributed to quantum interference effects, where the amplitude for certain outcomes constructively or destructively interferes. This is akin to the way probabilities for different quantum paths contribute to the observed outcomes in physical processes.
<br>         


            
</div>
        <img src="E18image2.png" alt="" class="experiment-image2">
        <p></p>
        <div class="content-block">

The 3D Density Plot of Quantum State Distributions above offers a way to view the distribution of measurements across different quantum states. In this plot, each point represents a measurement, with points clustered around different locations in 3D space corresponding to each quantum cluster. The density of points in each cluster reflects the count of measurements for that state.
<br>


            



</div>
        <img src="E18image3.png" alt="" class="experiment-image3">
        <p></p>
        <div class="content-block">

The Particle Interaction Line Chart above captures the run probabilities of the simulated 'electron' and 'positron' interactions leading to various annihilation outcomes. This chart abstractly represents the electron and positron as distinct paths, with their interaction probabilities over time. 
<br>

In the end, the simulation offers an abstract representation of an electron-positron annihilation. The higher probabilities for '01' and '10' could be abstractly interpreted as the simulation's equivalent of the conservation laws in real collisions, indicating a balance between the possible states post annihilation.
            
            
            
<br>
This type of quantum computation, in more complex ways, could serve as a bridge between abstract quantum theory and tangible experimental phenomena. Illustrating probabilistic principles of quantum mechanics and their possible implications for understanding the probabilities of particle interactions.

<br> 



</div>            
    
        
        <p>Code:<br>
            <p><pre><code># imports
from qiskit import QuantumCircuit, Aer, transpile, IBMQ, execute
from qiskit.visualization import plot_histogram
import json
from datetime import datetime
import matplotlib.pyplot as plt

# IBM Quantum api and backend
IBMQ.save_account('Your_IBM_Key_O-', overwrite=True)
IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
backend = provider.get_backend('ibm_kyoto')  # Adjust to your specific backend
print("Using backend: ", backend. name())

# Gate for annihilation process
def annihilation_gate(qc, electron_qubit, positron_qubit):
    qc. cx(electron_qubit, positron_qubit)
    qc.h(electron_qubit)
    qc.x(electron_qubit)
    qc. cx(positron_qubit, electron_qubit)

# Initialize a Quantum Circuit with 2 qubits (representing electron and positron)
qc = QuantumCircuit(2)

# Apply gates to represent the initial states of the electron and positron
qc.h(0)
qc.h(1)

# Apply custom annihilation gate
annihilation_gate(qc, 0, 1)

# Measure the qubits to observe the outcome
qc.measure_all()

# Transpile the circuit for the ibm_kyoto 
transpiled_qc = transpile(qc, backend)

# Execute the circuit on the ibm_kyoto 
job = execute(transpiled_qc, backend)
result = job.result()
counts = result.get_counts(transpiled_qc)
print(counts)

# Save relevant data to a JSON file
data = {
    'measurement_counts': counts,
    'circuit_transpiled': transpiled_qc.qasm(),
    'backend': backend. name(),
    'backend_properties': backend. properties().to_dict(),
    'job_id': job.job_id(),
    'status': job.status(),
    'result_data': result. to_dict(),
    'execution_date': datetime. now().strftime("%Y-%m-%d %H:%M:%S")
}
output_file = '/Users/Documents/ElectronPositronAnnihilation.json'
with open(output_file, 'w') as f:
    json.dump(data, f, indent=4, default=str)

# Display histogram of measurement results with counts
plot_histogram(counts, title='Measurement Results', bar_labels=True)
plt.show() 

# Feynman-like Diagram from Run Result Code
# imports
import json
import matplotlib.pyplot as plt
import numpy as np

# Load measurement counts from JSON 
with open('/Users/Documents/ElectronPositronAnnihilation.json', 'r') as file:
    measurement_counts = json.load(file)

# Define the figure for the Feynman-like diagram
fig, ax = plt.subplots(figsize=(8, 6))
ax.axis('off')  # Remove the axis as they are not needed
ax.set_xlim([0, 4])
ax.set_ylim([0, 4])

# Define positions for the particles and vertices in the diagram
electron_position = (1, 3)
positron_position = (1, 1)
interaction_vertex = (2, 2)
outcomes_positions = {
    '00': (3, 3),
    '01': (3, 2.5),
    '10': (3, 1.5),
    '11': (3, 1)
}

# Draw electron and positron lines to the interaction vertex
ax.annotate('', xy=interaction_vertex, xytext=electron_position,
            arrowprops=dict(facecolor='blue', shrink=0, width=2, headwidth=8))
ax.annotate('', xy=interaction_vertex, xytext=positron_position,
            arrowprops=dict(facecolor='red', shrink=0, width=2, headwidth=8))

# Label the electron and positron
ax.text(*electron_position, 'Electron (e-)', ha='right', va='center', fontsize=12, color='white')
ax.text(*positron_position, 'Positron (e+)', ha='right', va='center', fontsize=12, color='white')

# Draw outcome lines and label them, using the counts as probability amplitudes
for state, position in outcomes_positions.items():
    opacity = measurement_counts[state] / max(measurement_counts.values())  # Opacity based on relative count
    ax.annotate('', xy=position, xytext=interaction_vertex,
                arrowprops=dict(facecolor='green', alpha=opacity, shrink=0, width=2, headwidth=8))
    ax.text(*position, f'{state}: {measurement_counts[state]}', ha='left', va='center', fontsize=10, color='white')

# bg color
fig.patch.set_facecolor('black')
ax.set_facecolor('black')

# Display the Feynman-like diagram
plt.show()
        
           
            
    

  

    <footer>
        <!-- Footer content -->
        <a href="mailto:stevetippeconnic@gmail.com">Contact</a>
    </footer>

</body>
</html>
