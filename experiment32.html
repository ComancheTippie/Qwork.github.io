<!DOCTYPE html>
<html>
<head>
    <title>Experiment 20 - Qwork</title>
    <style>
       body {
            background-color: #000000; /* Black background */
            color: #FFFFFF; /* White text */
            font-family: Arial, sans-serif; /* Modern, sans-serif font */
            margin: 0;
            padding: 0;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            text-align: center;
            
        } 
        header {
            background: url('QImage4.png') no-repeat center center;
            background-size: contain; /* Ensure the image is fully contained within the header */
            height: 400px; /* Height as per the resized image */
            position: relative;
        }
        nav {
            display: flex;
            justify-content: center;
            padding: 10px 0;
        }
        nav a {
            color: #FFFFFF; /* White links */
            margin: 0 20px;
            text-decoration: none;
            font-size: 1.2em;
        }
        nav a:hover {
            color: #00FF00; /* Matrix green for hover state */
        }
        .content-section {
            padding: 20px;
            text-align: left;
        }
        .content-block {
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #00FF00; /* Matrix green border */
        }
        .experiment-image {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image2 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
         .experiment-image3 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
        .experiment-image4 {
            width: 1200px; /* Updated width */
            height: auto; /* Updated height */
            margin: 20px auto;
            display: block;
        }
       
        footer {
            color: #FFFFFF; /* White text */
            text-align: center;
            padding: 20px 0;
        }
        footer a {
            color: #FFFFFF;
            text-decoration: none;
        }
        footer a:hover {
            color: #00FF00; /* Matrix green on hover */
        }
    </style>
</head>
<body>

    <header>
        <!-- Header with the resized image -->
    </header>

    <nav>
        <!-- Navigation links as per wireframe -->
        <a href="try_yourself.html">Try Yourself</a>
        <a href="index.html">Experiments</a>
        <a href="about.html">About Me</a>
    </nav>

    <section class="content-section">
        <h1><center>Quantum Computation of Scattering Amplitudes Using Twistor Theory on a 127-Qubit IBM Quantum Computer </center></h1>
        <div class="content-block">
         
          

This experiment aims to compute scattering amplitudes in quantum field theory using a twistor-based formulation. This experiment uses a 127-Qubit IBM Quantum Computer and qiskit to simulate the complex interactions between particles during a scattering event. By representing particle states as qubits and encoding their interactions through quantum gates, we utilize the twistor theory to perform computations. The experiment consists of initializing qubit states, applying entangling operations to simulate particle interactions, performing unitary transformations inspired by twistor theory, and measuring the final quantum states to extract scattering amplitudes.<br>
<p>1. Initialization of the Quantum Circuit<br>
We initialize a quantum circuit with 127 qubits and 127 classical bits. The number of qubits represents the number of particles or degrees of freedom in the scattering process.<br>
The classical bits are used to store the measurement results of each qubit.<br>
Quantum Circuit: C(n, n) where n = 127<br>

<p>2. Random Initialization of Qubit States<br>
Each qubit is initialized to represent a possible quantum state of a particle involved in the scattering process.<br>
For each qubit q_i​ (where i = 0, 1, …, 126), we apply a rotation around the Y-axis using a randomly generated angle θ_i​.<br>
R_Y​(θ_i​) = exp(−i(θ_i/2)​​σ_y​)<br>
where θ_i​ is a random angle between 0 and 2π.<br>

<p>3. Entanglement to Simulate Particle Interactions<br>
To simulate the interactions between particles, we entangle pairs of qubits.<br>
We apply CNOT (Controlled-NOT) gates between adjacent qubits (q_i, q_(i+1)) for i = 0, 2, 4, …, 124.<br>
CNOT(q_i​, q_(i+1)​) = <br>
(I, 0​)<br>
(0, X​)<br>
where I is the identity matrix and X is the Pauli-X matrix (NOT gate).<br>

<p>4. Twistor-Inspired Unitary Transformations<br>
Twistor theory provides a geometric framework that simplifies the computation of scattering amplitudes. This simulates this by applying unitary transformations to each qubit.<br>
For each qubit q_i​, we generate a random 2x2 unitary matrix U_i and apply it as a gate.<br>
U_i​ = U(2) where U(2) is a unitary matrix satisfying U_(i)^† ​U_i ​= I<br>
The matrix U_i is generated using the Haar measure to ensure it is unitary.<br>

<p>5. Additional Entanglement to Simulate Higher-Order Interactions<br>
To simulate more complex interactions, this introduces additional entanglement between non-adjacent qubits.<br>
We apply CNOT gates between qubits (q_i, q_(i+2)) and (q_(i + 1), q_(i + 3)) for i = 0, 4, 8, …, 120.<br>
CNOT(q_i​, q_(i+2)​) and CNOT(q_(i + 1)​, q_(i+3)​)<br>

<p>6. Final Rotations to Encode Scattering Amplitudes
We apply a final set of rotations around the Z-axis to encode information about the scattering amplitudes.<br>
For each qubit q_i, a rotation gate R_Z(ϕ_i) is applied with a randomly generated angle ϕ_i​.<br>
R_Z​(ϕ_i​) = exp(−i(ϕ_i/2)​​σ_z​)<br>
where ϕ_i is a random angle between 0 and 2π.<br>

<p>7. Measurement of Qubit States<br>
The final state of each qubit is measured and stored in the corresponding classical bit. These measurements represent the outcome of the scattering process.<br>
Each qubit q_i is measured, and the result is stored in the classical register c_i​.<br>
M(q_i​) → c_i ​for i = 0, 1, …, 126<br>

<p>8. Transpilation and Optimization<br>
The quantum circuit is transpiled for the IBM 127-qubit quantum computer ibm_brisbane. This performs optimization using Qiskit’s transpiler with an optimization level of 3, focusing on reducing gate depth and error rates.<br>

<p>9. Execution on the IBM Quantum Backend<br>
The quantum circuit is executed on ibm_brisbane.<br>
The circuit is run with 8192 shots.<br>
Run(C, shots = 8192)<br>

<p>10. Extraction of Scattering Amplitudes<br>
The measurement results (counts) are used to compute the scattering amplitudes, which represent the probabilities of different outcomes of the scattering process.<br>
The counts are normalized to convert them into probabilities (scattering amplitudes).<br>
P_i ​= counts(c_i​)​/total counts<br>

<p>11. Saving and Visualization of Results<br>
The computed scattering amplitudes are saved to a JSON and a histogram is plotted. <br>
    
<p><center> Results:</center><br>
  
</div>
        <img src="Q31i1.jpeg" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">
<br>
The histogram above (top) (code below) shows the distribution of Hamming distances between all pairs of measurement outcomes from the quantum circuit.<br>

Peak at Hamming Distance ~60:<br>
The quantum results obtained exhibit a clear concentration around a Hamming distance of ~60, suggesting that the states produced by the quantum circuit are moderately similar rather than entirely random.<br>
The bell-shaped distribution of Hamming distances aligns with the idea that scattering amplitudes, when represented in twistor space, are not uniformly distributed but instead have a structured and symmetric pattern. This pattern may reflect the algebraic curves that support the amplitudes in twistor space.<br>

Classical predictions for scattering amplitudes derived from twistor theory have shown that these amplitudes can often be simplified compared to their traditional formulations in quantum field theory. For example, Witten’s formulation of twistor string theory demonstrated that scattering amplitudes in twistor space exhibit high simplicity. These amplitudes are supported on algebraic curves, suggesting a deep connection between the geometry of twistor space and the physical scattering processes. This leads to a more compact and symmetric representation of amplitudes, often expressed in terms of Grassmannian residue formulas, polytopes, and the amplituhedron in twistor space.<br>

The Fourier Transform of the mean binary string above (bottom) (code below) reveals a prominent spike at the zero frequency (DC component) and relatively low amplitudes across all other frequencies. This indicates that there is a strong constant component in the mean binary string, with very little variation in periodic components.<br>
The significant spike at zero frequency suggests that the mean binary string has a strong constant value, indicating that most of the bits in the mean string are close to a constant value (either mostly 0s or mostly 1s). This could imply that there is a high degree of consistency in the states that are being measured, reflecting an underlying structure or symmetry.<br>
In the context of twistor scattering amplitudes, the absence of strong periodic signals could suggest that the quantum circuit is capturing the non-periodic, continuous aspects of the scattering process. Twistor theory often simplifies scattering amplitudes by mapping complex interactions to geometrically simple objects in twistor space, but the underlying structure might not be periodic.<br>

          

</div>
        <img src="Q31i2.jpeg" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">
<br>

The PCA plot above (top) (code below) reveals that the binary strings cluster into distinct groups along the principal components, with noticeable gaps between these clusters.<br>
The clustering observed in the PCA may indicate that the quantum circuit is sampling from distinct regions of the state space, possibly corresponding to different scattering events or configurations in twistor space. The separation of clusters suggests that the circuit outputs are not uniformly random but exhibit structured patterns, which aligns with the idea that twistor-inspired quantum circuits explore well defined regions of the state space.<br>

The t-SNE plot above (bottom) (code below) shows a more continuous distribution without distinct clusters, forming an oval shaped distribution.<br>
While t-SNE is sensitive to local similarities, the lack of distinct clustering in this plot suggests that, on a finer scale, the binary strings are more evenly distributed. This could indicate that while PCA reveals macro structure (global patterns), the quantum states are more uniformly spread when viewed through the lens of local similarities. This uniformity may suggest that the circuit captures a broader range of scattering events, each with subtle differences, which is consistent with the high complexity and variation expected in twistor scattering amplitudes.<br>

          
</div>
        <img src="Q31i3.jpeg" alt="" class="experiment-image">
        <p></p>
        <div class="content-block">
<br>
The Correlation Matrix of Binary Strings above (top) (code below) shows strong diagonal dominance, with relatively low off-diagonal correlations. The strong diagonal suggests that each bit is largely independent of the others, which is typical for high entropy, complex quantum systems. The few areas of off diagonal correlation might indicate interactions between specific qubits, possibly linked to the structure of the scattering amplitudes. The overall low correlation between most bit positions suggests that the quantum states do not exhibit simple, pairwise correlations but rather reflect a more intricate structure.<br>

Lastly, the Entropy Plot above (bottom) (code below) shows that most bit positions have high entropy, with a few positions having slightly lower values. High entropy across most bit positions indicates that the bits are highly variable and not overly constrained, which aligns with the expected complexity of twistor-based scattering processes. The lower entropy in some positions might point to specific bits being more deterministic.<br>

Entropy of Hamming distances: 3.1998136310587184<br>
Total palindromic strings found: 0<br>
The entropy of the Hamming distances is approximately 3.2, indicating a moderate spread of distances. This moderate entropy suggests that while there is some diversity in the Hamming distances (reflecting variation in the quantum states), the distribution is not entirely random. This aligns with the earlier observations of structured patterns in the state space. <br>

In the end, the results show that the quantum circuit is exploring structured regions of the state space, consistent with the complex, high-dimensional nature of twistor scattering amplitudes. The clustering observed in PCA, the broad distribution seen in t-SNE, and the high entropy across bit positions all suggest that the quantum circuit captures a wide variety of states with underlying structure. The lack of simple symmetries, such as palindromes, further supports the complexity of the twistor based model.<br>

            
        
        <p>Code:<br>
            <p><pre><code>(10 Qubit Circuit)
# imports
import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit_ibm_runtime import QiskitRuntimeService, Session, SamplerV2
from qiskit.circuit.library import UnitaryGate
from qiskit.visualization import plot_histogram
import json
import logging
import matplotlib.pyplot as plt
from datetime import datetime
from scipy.stats import unitary_group

# Setup logging
logging.basicConfig(level=logging. INFO, filename='scattering_amplitudes.log',
filemode='w', format='%(asctime)s - %(levelname)s - %(message)s')

# Function to serialize datetime objects
def datetime_converter(o):
if isinstance(o, datetime):
return o.isoformat()

# Initialize IBM Qiskit Runtime Service 
service = QiskitRuntimeService(
channel='ibm_quantum',
instance='ibm-q/open/main',
token='YOUR_IBMQ_KEY_O-`' 
)

# Choose the backend 
backend = service.backend("ibm_brisbane")

# Retrieve and print calibration data for record-keeping
calibration_data = backend. properties().to_dict()
logging. info("Backend Calibration Data: %s", json.dumps(calibration_data, indent=4, default=datetime_converter))

# Define number of qubits and classical bits
num_qubits = 127
quantum_circuit = QuantumCircuit(num_qubits, num_qubits)  # Added classical bits for measurements

# Random initialization of qubit states (representing particles)
for i in range(num_qubits):
theta = np.random.rand() * 2 * np.pi
quantum_circuit.ry(theta, i)

# Entangle qubits to simulate interactions between particles
for i in range(0, num_qubits - 1, 2):  # Ensure we don't go out of bounds
quantum_circuit.cx(i, i+1)

# Apply twistor Unitary transformations
for i in range(num_qubits):
# Generate a random unitary matrix representing twistor transformations
u_matrix = unitary_group.rvs(2)
unitary_gate = UnitaryGate(u_matrix)
quantum_circuit.append(unitary_gate, [i])

# Additional entanglement to mimic higher order particle interactions
for i in range(0, num_qubits - 3, 4):  # Ensure we don't go out of bounds
quantum_circuit.cx(i, i+2)
quantum_circuit.cx(i+1, i+3)

# Final set of rotations to encode the scattering amplitude information
for i in range(num_qubits):
phi = np.random.rand() * 2 * np.pi
quantum_circuit.rz(phi, i)

# Measurement to the classical bits
quantum_circuit.measure(range(num_qubits), range(num_qubits))

# Transpile the quantum circuit
transpiled_circuit = transpile(quantum_circuit, backend=backend, optimization_level=3)

# Log transpiled circuit depth and gate count
logging. info("Transpiled Circuit Depth: %d", transpiled_circuit.depth())
logging. info("Transpiled Circuit Gate Count: %s", transpiled_circuit.count_ops())

# Execution on backend with SamplerV2
with Session(service=service, backend=backend) as session:
sampler = SamplerV2(session=session)
# Run the circuit
job = sampler. run([transpiled_circuit], shots=8192)
job_result = job.result()
# Retrieve the classical register name
classical_register = quantum_circuit.cregs[0].name
# Extract counts for the first (and only) pub result
pub_result = job_result[0].data[classical_register].get_counts()

# Save the results to JSON
results_data = {

"raw_counts": pub_result
}
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path, 'w') as f:
json.dump(results_data, f, indent=4)
# Plotting the results for analysis
plot_histogram(pub_result)
plt.title("Scattering Amplitudes")

plt.savefig('/Users/Documents/scattering_amplitudes_histogram.png')
plt. show()

////////////////////////////////////////////////////////////////

Code for Hamming Distances Visual from Run Data
import json
import matplotlib.pyplot as plt
from itertools import combinations
from scipy.spatial.distance import hamming
import numpy as np

# Load the results JSON file
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path) as f:
    results_data = json.load(f)

# Extract the binary strings (keys) from the raw counts
binary_strings = list(results_data['raw_counts'].keys())

# Convert binary strings to arrays of integers
binary_arrays = [np.array(list(map(int, list(binary_string)))) for binary_string in binary_strings]

# Calculate Hamming distances between all pairs of binary strings
hamming_distances = [
    hamming(pair[0], pair[1]) * len(binary_arrays[0])  # Convert normalized distance to absolute number of differing bits
    for pair in combinations(binary_arrays, 2)
]

# Plot the histogram of Hamming distances
plt.figure(figsize=(10, 6))
plt.hist(hamming_distances, bins=range(0, len(binary_arrays[0]) + 1), edgecolor='black', alpha=0.7)
plt.title('Distribution of Hamming Distances between Measurement Outcomes')
plt.xlabel('Hamming Distance')
plt.ylabel('Frequency')
plt.grid(True)
plt.savefig('/Users/steventippeconnic/Documents/QC/hamming_distance_distribution.png')  # Save the plot
plt. show()

/////////////////////////////////////////////////////////////////

Code for the Fourier Transform of the mean binary string Visual with Run Data
import json
import numpy as np
import matplotlib.pyplot as plt

# Load the results JSON file
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path) as f:
    results_data = json.load(f)

# Extract the binary strings (keys) from the raw counts
binary_strings = list(results_data['raw_counts'].keys())

# Convert binary strings to arrays of integers
binary_arrays = np.array([list(map(int, list(binary_string))) for binary_string in binary_strings])

# Compute the mean binary string
mean_binary_array = np.mean(binary_arrays, axis=0)

# Perform Fourier transform on the mean binary array
fourier_transform = np.fft.fft(mean_binary_array)
frequencies = np.fft.fftfreq(len(mean_binary_array))

# Plot the Fourier Transform results
plt.figure(figsize=(10, 6))
plt.plot(frequencies, np.abs(fourier_transform))
plt.title('Fourier Transform of Mean Binary String')
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.grid(True)
plt.savefig('/Users/steventippeconnic/Documents/QC/fourier_scattering_amplitudes.png')
plt. show()

/////////////////////////////////////////////////////////////////

Code for Principal Component Analysis (PCA) Visual from Run Data
import json
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

# Load the results JSON file
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path) as f:
results_data = json.load(f)

# Extract the binary strings (keys) from the raw counts
binary_strings = list(results_data['raw_counts'].keys())

# Convert binary strings to arrays of integers
binary_arrays = np.array([list(map(int, list(binary_string))) for binary_string in binary_strings])

# Perform PCA
pca = PCA(n_components=2)
principal_components = pca. fit_transform(binary_arrays)

# Plot the results
plt.figure(figsize=(10, 6))
plt.scatter(principal_components[:, 0], principal_components[:, 1], alpha=0.7)
plt.title('PCA of Binary Strings from Scattering Amplitudes')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.savefig('/Users/steventippeconnic/Documents/QC/pca_scattering_amplitudes.png')
plt. show()

///////////////////////////////////////////////////////////////

Code for t-SNE (t-Distributed Stochastic Neighbor Embedding) Visual from Run Data
import json
import numpy as np
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE

# Load the results JSON file
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path) as f:
    results_data = json.load(f)

# Extract the binary strings (keys) from the raw counts
binary_strings = list(results_data['raw_counts'].keys())

# Convert binary strings to arrays of integers
binary_arrays = np.array([list(map(int, list(binary_string))) for binary_string in binary_strings])

# Perform t-SNE
tsne = TSNE(n_components=2, random_state=42)
tsne_results = tsne. fit_transform(binary_arrays)

# Plot the results
plt.figure(figsize=(10, 6))
plt.scatter(tsne_results[:, 0], tsne_results[:, 1], alpha=0.7)
plt.title('t-SNE of Binary Strings from Scattering Amplitudes')
plt.xlabel('t-SNE Component 1')
plt.ylabel('t-SNE Component 2')
plt.grid(True)
plt.savefig('/Users/steventippeconnic/Documents/QC/tsne_scattering_amplitudes.png')
plt.s how()

///////////////////////////////////////////////////////////////

Code for Entropy Analysis Visual from Run Data
import json
import numpy as np
from scipy.stats import entropy
import matplotlib.pyplot as plt

# Load the results JSON file
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path) as f:
    results_data = json.load(f)

# Extract the binary strings (keys) from the raw counts
binary_strings = list(results_data['raw_counts'].keys())

# Convert binary strings to arrays of integers
binary_arrays = np.array([list(map(int, list(binary_string))) for binary_string in binary_strings])

# Calculate entropy for each bit position across all strings
bitwise_entropy = [entropy(np.bincount(binary_arrays[:, i])) for i in range(binary_arrays.shape[1])]

# Plot the entropy values
plt.figure(figsize=(10, 6))
plt. bar(range(len(bitwise_entropy)), bitwise_entropy)
plt.title('Entropy of Each Bit Position Across All Binary Strings')
plt.xlabel('Bit Position')
plt.ylabel('Entropy')
plt.grid(True)
plt.savefig('/Users/steventippeconnic/Documents/QC/entropy_scattering_amplitudes.png')
plt. show()

///////////////////////////////////////////////////////////////

Code for Correlation Analysis Visual from Run Data
import json
import numpy as np
import matplotlib.pyplot as plt

# Load the results JSON file
file_path = '/Users/Documents/scattering_amplitudes_result.json'
with open(file_path) as f:
    results_data = json.load(f)

# Extract the binary strings (keys) from the raw counts
binary_strings = list(results_data['raw_counts'].keys())

# Convert binary strings to arrays of integers
binary_arrays = np.array([list(map(int, list(binary_string))) for binary_string in binary_strings])

# Calculate the correlation matrix
correlation_matrix = np.corrcoef(binary_arrays, rowvar=False)

# Plot the correlation matrix
plt.figure(figsize=(10, 8))
plt.imshow(correlation_matrix, cmap='viridis', interpolation='none')
plt.colorbar()
plt.title('Correlation Matrix of Binary Strings')
plt.xlabel('Bit Position')
plt.ylabel('Bit Position')
plt.savefig('/Users/steventippeconnic/Documents/QC/correlation_scattering_amplitudes.png')
plt. show()

# End


</code></pre>
</p>
            
 </div>
        <img src="Q31i4.jpeg" alt="" class="experiment-image4">
        <p></p>
        <div class="content-block">

           
            <br>
    

  

    <footer>
        <!-- Footer content -->
        <a href="mailto:stevetippeconnic@gmail.com">Contact</a>
    </footer>

</body>
</html>
